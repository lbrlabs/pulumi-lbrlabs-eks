// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package eks

import (
	"context"
	"reflect"

	"github.com/lbrlabs/pulumi-lbrlabs-eks/sdk/go/eks/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

var _ = internal.GetEnvOrDefault

// Configuration for Autoscaled Node budgets.
type BudgetConfig struct {
	// The duration during which disruptuon can happen.
	Duration *string `pulumi:"duration"`
	// The maximum number of nodes that can be scaled down at any time.
	Nodes *string `pulumi:"nodes"`
	// A cron schedule for when disruption can happen.
	Schedule *string `pulumi:"schedule"`
}

// Configuration for Autoscaled Node budgets.
type BudgetConfigArgs struct {
	// The duration during which disruptuon can happen.
	Duration pulumix.Input[*string] `pulumi:"duration"`
	// The maximum number of nodes that can be scaled down at any time.
	Nodes pulumix.Input[*string] `pulumi:"nodes"`
	// A cron schedule for when disruption can happen.
	Schedule pulumix.Input[*string] `pulumi:"schedule"`
}

func (BudgetConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BudgetConfig)(nil)).Elem()
}

func (i BudgetConfigArgs) ToBudgetConfigOutput() BudgetConfigOutput {
	return i.ToBudgetConfigOutputWithContext(context.Background())
}

func (i BudgetConfigArgs) ToBudgetConfigOutputWithContext(ctx context.Context) BudgetConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BudgetConfigOutput)
}

func (i *BudgetConfigArgs) ToOutput(ctx context.Context) pulumix.Output[*BudgetConfigArgs] {
	return pulumix.Val(i)
}

// Configuration for Autoscaled Node budgets.
type BudgetConfigOutput struct{ *pulumi.OutputState }

func (BudgetConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BudgetConfig)(nil)).Elem()
}

func (o BudgetConfigOutput) ToBudgetConfigOutput() BudgetConfigOutput {
	return o
}

func (o BudgetConfigOutput) ToBudgetConfigOutputWithContext(ctx context.Context) BudgetConfigOutput {
	return o
}

func (o BudgetConfigOutput) ToOutput(ctx context.Context) pulumix.Output[BudgetConfig] {
	return pulumix.Output[BudgetConfig]{
		OutputState: o.OutputState,
	}
}

// The duration during which disruptuon can happen.
func (o BudgetConfigOutput) Duration() pulumix.Output[*string] {
	return pulumix.Apply[BudgetConfig](o, func(v BudgetConfig) *string { return v.Duration })
}

// The maximum number of nodes that can be scaled down at any time.
func (o BudgetConfigOutput) Nodes() pulumix.Output[*string] {
	return pulumix.Apply[BudgetConfig](o, func(v BudgetConfig) *string { return v.Nodes })
}

// A cron schedule for when disruption can happen.
func (o BudgetConfigOutput) Schedule() pulumix.Output[*string] {
	return pulumix.Apply[BudgetConfig](o, func(v BudgetConfig) *string { return v.Schedule })
}

// Configuration for Autoscaled nodes disruption.
type DisruptionConfig struct {
	// Budgets control the speed Karpenter can scale down nodes.
	Budgets []*BudgetConfig `pulumi:"budgets"`
	// The amount of time Karpenter should wait after discovering a consolidation decision. This value can currently only be set when the consolidationPolicy is 'WhenEmpty'. You can choose to disable consolidation entirely by setting the string value 'Never' here.
	ConsolidateAfter *string `pulumi:"consolidateAfter"`
	// Describes which types of Nodes Karpenter should consider for consolidation.
	ConsolidationPolicy *string `pulumi:"consolidationPolicy"`
	// The amount of time a Node can live on the cluster before being removed.
	ExpireAfter *string `pulumi:"expireAfter"`
}

// Defaults sets the appropriate defaults for DisruptionConfig
func (val *DisruptionConfig) Defaults() *DisruptionConfig {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ConsolidationPolicy == nil {
		consolidationPolicy_ := "WhenUnderutilized"
		tmp.ConsolidationPolicy = &consolidationPolicy_
	}
	if tmp.ExpireAfter == nil {
		expireAfter_ := "720h"
		tmp.ExpireAfter = &expireAfter_
	}
	return &tmp
}

// Configuration for Autoscaled nodes disruption.
type DisruptionConfigArgs struct {
	// Budgets control the speed Karpenter can scale down nodes.
	Budgets pulumix.Input[[]*BudgetConfigArgs] `pulumi:"budgets"`
	// The amount of time Karpenter should wait after discovering a consolidation decision. This value can currently only be set when the consolidationPolicy is 'WhenEmpty'. You can choose to disable consolidation entirely by setting the string value 'Never' here.
	ConsolidateAfter pulumix.Input[*string] `pulumi:"consolidateAfter"`
	// Describes which types of Nodes Karpenter should consider for consolidation.
	ConsolidationPolicy pulumix.Input[*string] `pulumi:"consolidationPolicy"`
	// The amount of time a Node can live on the cluster before being removed.
	ExpireAfter pulumix.Input[*string] `pulumi:"expireAfter"`
}

// Defaults sets the appropriate defaults for DisruptionConfigArgs
func (val *DisruptionConfigArgs) Defaults() *DisruptionConfigArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ConsolidationPolicy == nil {
		tmp.ConsolidationPolicy = pulumix.Ptr("WhenUnderutilized")
	}
	if tmp.ExpireAfter == nil {
		tmp.ExpireAfter = pulumix.Ptr("720h")
	}
	return &tmp
}
func (DisruptionConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DisruptionConfig)(nil)).Elem()
}

func (i DisruptionConfigArgs) ToDisruptionConfigOutput() DisruptionConfigOutput {
	return i.ToDisruptionConfigOutputWithContext(context.Background())
}

func (i DisruptionConfigArgs) ToDisruptionConfigOutputWithContext(ctx context.Context) DisruptionConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DisruptionConfigOutput)
}

func (i *DisruptionConfigArgs) ToOutput(ctx context.Context) pulumix.Output[*DisruptionConfigArgs] {
	return pulumix.Val(i)
}

// Configuration for Autoscaled nodes disruption.
type DisruptionConfigOutput struct{ *pulumi.OutputState }

func (DisruptionConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DisruptionConfig)(nil)).Elem()
}

func (o DisruptionConfigOutput) ToDisruptionConfigOutput() DisruptionConfigOutput {
	return o
}

func (o DisruptionConfigOutput) ToDisruptionConfigOutputWithContext(ctx context.Context) DisruptionConfigOutput {
	return o
}

func (o DisruptionConfigOutput) ToOutput(ctx context.Context) pulumix.Output[DisruptionConfig] {
	return pulumix.Output[DisruptionConfig]{
		OutputState: o.OutputState,
	}
}

// Budgets control the speed Karpenter can scale down nodes.
func (o DisruptionConfigOutput) Budgets() pulumix.GArrayOutput[BudgetConfig, BudgetConfigOutput] {
	value := pulumix.Apply[DisruptionConfig](o, func(v DisruptionConfig) []*BudgetConfig { return v.Budgets })
	return pulumix.GArrayOutput[BudgetConfig, BudgetConfigOutput]{OutputState: value.OutputState}
}

// The amount of time Karpenter should wait after discovering a consolidation decision. This value can currently only be set when the consolidationPolicy is 'WhenEmpty'. You can choose to disable consolidation entirely by setting the string value 'Never' here.
func (o DisruptionConfigOutput) ConsolidateAfter() pulumix.Output[*string] {
	return pulumix.Apply[DisruptionConfig](o, func(v DisruptionConfig) *string { return v.ConsolidateAfter })
}

// Describes which types of Nodes Karpenter should consider for consolidation.
func (o DisruptionConfigOutput) ConsolidationPolicy() pulumix.Output[*string] {
	return pulumix.Apply[DisruptionConfig](o, func(v DisruptionConfig) *string { return v.ConsolidationPolicy })
}

// The amount of time a Node can live on the cluster before being removed.
func (o DisruptionConfigOutput) ExpireAfter() pulumix.Output[*string] {
	return pulumix.Apply[DisruptionConfig](o, func(v DisruptionConfig) *string { return v.ExpireAfter })
}

// Configuration for the ingress controller.
type IngressConfig struct {
	// Additional configuration for the ingress controller.
	AdditionalConfig map[string]string `pulumi:"additionalConfig"`
	// The number of replicas of the ingress controller.
	ControllerReplicas *float64 `pulumi:"controllerReplicas"`
	// Enable metrics for the ingress controller.
	EnableMetrics *bool `pulumi:"enableMetrics"`
	// Enable the service monitor for kube-prometheus-stackl.
	EnableServiceMonitor *bool `pulumi:"enableServiceMonitor"`
	// NLB target type for NLB loadbalancers.
	NlbTargetType *string `pulumi:"nlbTargetType"`
	// The namespace to deploy the service monitor to.
	ServiceMonitorNamespace *string `pulumi:"serviceMonitorNamespace"`
}

// Defaults sets the appropriate defaults for IngressConfig
func (val *IngressConfig) Defaults() *IngressConfig {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ControllerReplicas == nil {
		controllerReplicas_ := 1.0
		tmp.ControllerReplicas = &controllerReplicas_
	}
	if tmp.EnableMetrics == nil {
		enableMetrics_ := false
		tmp.EnableMetrics = &enableMetrics_
	}
	if tmp.EnableServiceMonitor == nil {
		enableServiceMonitor_ := false
		tmp.EnableServiceMonitor = &enableServiceMonitor_
	}
	if tmp.NlbTargetType == nil {
		nlbTargetType_ := "ip"
		tmp.NlbTargetType = &nlbTargetType_
	}
	return &tmp
}

// Configuration for the ingress controller.
type IngressConfigArgs struct {
	// Additional configuration for the ingress controller.
	AdditionalConfig pulumix.Input[map[string]string] `pulumi:"additionalConfig"`
	// The number of replicas of the ingress controller.
	ControllerReplicas pulumix.Input[*float64] `pulumi:"controllerReplicas"`
	// Enable metrics for the ingress controller.
	EnableMetrics pulumix.Input[*bool] `pulumi:"enableMetrics"`
	// Enable the service monitor for kube-prometheus-stackl.
	EnableServiceMonitor pulumix.Input[*bool] `pulumi:"enableServiceMonitor"`
	// NLB target type for NLB loadbalancers.
	NlbTargetType pulumix.Input[*string] `pulumi:"nlbTargetType"`
	// The namespace to deploy the service monitor to.
	ServiceMonitorNamespace pulumix.Input[*string] `pulumi:"serviceMonitorNamespace"`
}

// Defaults sets the appropriate defaults for IngressConfigArgs
func (val *IngressConfigArgs) Defaults() *IngressConfigArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ControllerReplicas == nil {
		tmp.ControllerReplicas = pulumix.Ptr(1.0)
	}
	if tmp.EnableMetrics == nil {
		tmp.EnableMetrics = pulumix.Ptr(false)
	}
	if tmp.EnableServiceMonitor == nil {
		tmp.EnableServiceMonitor = pulumix.Ptr(false)
	}
	if tmp.NlbTargetType == nil {
		tmp.NlbTargetType = pulumix.Ptr("ip")
	}
	return &tmp
}
func (IngressConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressConfig)(nil)).Elem()
}

func (i IngressConfigArgs) ToIngressConfigOutput() IngressConfigOutput {
	return i.ToIngressConfigOutputWithContext(context.Background())
}

func (i IngressConfigArgs) ToIngressConfigOutputWithContext(ctx context.Context) IngressConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IngressConfigOutput)
}

func (i *IngressConfigArgs) ToOutput(ctx context.Context) pulumix.Output[*IngressConfigArgs] {
	return pulumix.Val(i)
}

// Configuration for the ingress controller.
type IngressConfigOutput struct{ *pulumi.OutputState }

func (IngressConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressConfig)(nil)).Elem()
}

func (o IngressConfigOutput) ToIngressConfigOutput() IngressConfigOutput {
	return o
}

func (o IngressConfigOutput) ToIngressConfigOutputWithContext(ctx context.Context) IngressConfigOutput {
	return o
}

func (o IngressConfigOutput) ToOutput(ctx context.Context) pulumix.Output[IngressConfig] {
	return pulumix.Output[IngressConfig]{
		OutputState: o.OutputState,
	}
}

// Additional configuration for the ingress controller.
func (o IngressConfigOutput) AdditionalConfig() pulumix.MapOutput[string] {
	value := pulumix.Apply[IngressConfig](o, func(v IngressConfig) map[string]string { return v.AdditionalConfig })
	return pulumix.MapOutput[string]{OutputState: value.OutputState}
}

// The number of replicas of the ingress controller.
func (o IngressConfigOutput) ControllerReplicas() pulumix.Output[*float64] {
	return pulumix.Apply[IngressConfig](o, func(v IngressConfig) *float64 { return v.ControllerReplicas })
}

// Enable metrics for the ingress controller.
func (o IngressConfigOutput) EnableMetrics() pulumix.Output[*bool] {
	return pulumix.Apply[IngressConfig](o, func(v IngressConfig) *bool { return v.EnableMetrics })
}

// Enable the service monitor for kube-prometheus-stackl.
func (o IngressConfigOutput) EnableServiceMonitor() pulumix.Output[*bool] {
	return pulumix.Apply[IngressConfig](o, func(v IngressConfig) *bool { return v.EnableServiceMonitor })
}

// NLB target type for NLB loadbalancers.
func (o IngressConfigOutput) NlbTargetType() pulumix.Output[*string] {
	return pulumix.Apply[IngressConfig](o, func(v IngressConfig) *string { return v.NlbTargetType })
}

// The namespace to deploy the service monitor to.
func (o IngressConfigOutput) ServiceMonitorNamespace() pulumix.Output[*string] {
	return pulumix.Apply[IngressConfig](o, func(v IngressConfig) *string { return v.ServiceMonitorNamespace })
}

// Represents a single requirement with key, operator, and values.
type Requirement struct {
	// The key of the requirement.
	Key *string `pulumi:"key"`
	// The operator for the requirement (e.g., In, Gt).
	Operator *string `pulumi:"operator"`
	// The list of values for the requirement.
	Values []string `pulumi:"values"`
}

// Represents a single requirement with key, operator, and values.
type RequirementArgs struct {
	// The key of the requirement.
	Key pulumix.Input[*string] `pulumi:"key"`
	// The operator for the requirement (e.g., In, Gt).
	Operator pulumix.Input[*string] `pulumi:"operator"`
	// The list of values for the requirement.
	Values pulumix.Input[[]string] `pulumi:"values"`
}

func (RequirementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Requirement)(nil)).Elem()
}

func (i RequirementArgs) ToRequirementOutput() RequirementOutput {
	return i.ToRequirementOutputWithContext(context.Background())
}

func (i RequirementArgs) ToRequirementOutputWithContext(ctx context.Context) RequirementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequirementOutput)
}

func (i *RequirementArgs) ToOutput(ctx context.Context) pulumix.Output[*RequirementArgs] {
	return pulumix.Val(i)
}

// Represents a single requirement with key, operator, and values.
type RequirementOutput struct{ *pulumi.OutputState }

func (RequirementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Requirement)(nil)).Elem()
}

func (o RequirementOutput) ToRequirementOutput() RequirementOutput {
	return o
}

func (o RequirementOutput) ToRequirementOutputWithContext(ctx context.Context) RequirementOutput {
	return o
}

func (o RequirementOutput) ToOutput(ctx context.Context) pulumix.Output[Requirement] {
	return pulumix.Output[Requirement]{
		OutputState: o.OutputState,
	}
}

// The key of the requirement.
func (o RequirementOutput) Key() pulumix.Output[*string] {
	return pulumix.Apply[Requirement](o, func(v Requirement) *string { return v.Key })
}

// The operator for the requirement (e.g., In, Gt).
func (o RequirementOutput) Operator() pulumix.Output[*string] {
	return pulumix.Apply[Requirement](o, func(v Requirement) *string { return v.Operator })
}

// The list of values for the requirement.
func (o RequirementOutput) Values() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[Requirement](o, func(v Requirement) []string { return v.Values })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// Represents a taint for a karpenter node.
type Taint struct {
	// The effect of the taint.
	Effect []string `pulumi:"effect"`
	// The key of the taint.
	Key *string `pulumi:"key"`
	// The value of the taint.
	Value *string `pulumi:"value"`
}

func init() {
	pulumi.RegisterOutputType(BudgetConfigOutput{})
	pulumi.RegisterOutputType(DisruptionConfigOutput{})
	pulumi.RegisterOutputType(IngressConfigOutput{})
	pulumi.RegisterOutputType(RequirementOutput{})
}
