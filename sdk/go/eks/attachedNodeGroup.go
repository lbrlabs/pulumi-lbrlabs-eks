// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package eks

import (
	"context"
	"reflect"

	"errors"
	"github.com/lbrlabs/pulumi-lbrlabs-eks/sdk/go/eks/internal"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/eks"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/iam"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type AttachedNodeGroup struct {
	pulumi.ResourceState

	NodeGroup eks.NodeGroupOutput `pulumi:"nodeGroup"`
	NodeRole  iam.RoleOutput      `pulumi:"nodeRole"`
}

// NewAttachedNodeGroup registers a new resource with the given unique name, arguments, and options.
func NewAttachedNodeGroup(ctx *pulumi.Context,
	name string, args *AttachedNodeGroupArgs, opts ...pulumi.ResourceOption) (*AttachedNodeGroup, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterName == nil {
		return nil, errors.New("invalid value for required argument 'ClusterName'")
	}
	if args.SubnetIds == nil {
		return nil, errors.New("invalid value for required argument 'SubnetIds'")
	}
	if args.CapacityType == nil {
		args.CapacityType = pulumi.StringPtr("ON_DEMAND")
	}
	if args.DiskSize == nil {
		args.DiskSize = pulumi.IntPtr(20)
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AttachedNodeGroup
	err := ctx.RegisterRemoteComponentResource("lbrlabs-eks:index:AttachedNodeGroup", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type attachedNodeGroupArgs struct {
	// The AMI Type for the nodegroup.
	AmiType *string `pulumi:"amiType"`
	// The capacity type of the nodegroup.
	CapacityType *string `pulumi:"capacityType"`
	// The cluster name to attach the nodegroup tp.
	ClusterName string `pulumi:"clusterName"`
	// The size of the disk to attach to the nodes.
	DiskSize      *int     `pulumi:"diskSize"`
	InstanceTypes []string `pulumi:"instanceTypes"`
	// Key-value map of Kubernetes labels. Only labels that are applied with the EKS API are managed by this argument. Other Kubernetes labels applied to the EKS Node Group will not be managed.
	Labels map[string]string `pulumi:"labels"`
	// The release version for the nodegroup.
	ReleaseVersion *string                     `pulumi:"releaseVersion"`
	ScalingConfig  *eks.NodeGroupScalingConfig `pulumi:"scalingConfig"`
	SubnetIds      []string                    `pulumi:"subnetIds"`
	// Key-value map of tags to apply to the nodegroup.
	Tags   map[string]string    `pulumi:"tags"`
	Taints []eks.NodeGroupTaint `pulumi:"taints"`
}

// The set of arguments for constructing a AttachedNodeGroup resource.
type AttachedNodeGroupArgs struct {
	// The AMI Type for the nodegroup.
	AmiType pulumi.StringPtrInput
	// The capacity type of the nodegroup.
	CapacityType pulumi.StringPtrInput
	// The cluster name to attach the nodegroup tp.
	ClusterName pulumi.StringInput
	// The size of the disk to attach to the nodes.
	DiskSize      pulumi.IntPtrInput
	InstanceTypes pulumi.StringArrayInput
	// Key-value map of Kubernetes labels. Only labels that are applied with the EKS API are managed by this argument. Other Kubernetes labels applied to the EKS Node Group will not be managed.
	Labels pulumi.StringMapInput
	// The release version for the nodegroup.
	ReleaseVersion pulumi.StringPtrInput
	ScalingConfig  eks.NodeGroupScalingConfigPtrInput
	SubnetIds      pulumi.StringArrayInput
	// Key-value map of tags to apply to the nodegroup.
	Tags   pulumi.StringMapInput
	Taints eks.NodeGroupTaintArrayInput
}

func (AttachedNodeGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*attachedNodeGroupArgs)(nil)).Elem()
}

type AttachedNodeGroupInput interface {
	pulumi.Input

	ToAttachedNodeGroupOutput() AttachedNodeGroupOutput
	ToAttachedNodeGroupOutputWithContext(ctx context.Context) AttachedNodeGroupOutput
}

func (*AttachedNodeGroup) ElementType() reflect.Type {
	return reflect.TypeOf((**AttachedNodeGroup)(nil)).Elem()
}

func (i *AttachedNodeGroup) ToAttachedNodeGroupOutput() AttachedNodeGroupOutput {
	return i.ToAttachedNodeGroupOutputWithContext(context.Background())
}

func (i *AttachedNodeGroup) ToAttachedNodeGroupOutputWithContext(ctx context.Context) AttachedNodeGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttachedNodeGroupOutput)
}

// AttachedNodeGroupArrayInput is an input type that accepts AttachedNodeGroupArray and AttachedNodeGroupArrayOutput values.
// You can construct a concrete instance of `AttachedNodeGroupArrayInput` via:
//
//	AttachedNodeGroupArray{ AttachedNodeGroupArgs{...} }
type AttachedNodeGroupArrayInput interface {
	pulumi.Input

	ToAttachedNodeGroupArrayOutput() AttachedNodeGroupArrayOutput
	ToAttachedNodeGroupArrayOutputWithContext(context.Context) AttachedNodeGroupArrayOutput
}

type AttachedNodeGroupArray []AttachedNodeGroupInput

func (AttachedNodeGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AttachedNodeGroup)(nil)).Elem()
}

func (i AttachedNodeGroupArray) ToAttachedNodeGroupArrayOutput() AttachedNodeGroupArrayOutput {
	return i.ToAttachedNodeGroupArrayOutputWithContext(context.Background())
}

func (i AttachedNodeGroupArray) ToAttachedNodeGroupArrayOutputWithContext(ctx context.Context) AttachedNodeGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttachedNodeGroupArrayOutput)
}

// AttachedNodeGroupMapInput is an input type that accepts AttachedNodeGroupMap and AttachedNodeGroupMapOutput values.
// You can construct a concrete instance of `AttachedNodeGroupMapInput` via:
//
//	AttachedNodeGroupMap{ "key": AttachedNodeGroupArgs{...} }
type AttachedNodeGroupMapInput interface {
	pulumi.Input

	ToAttachedNodeGroupMapOutput() AttachedNodeGroupMapOutput
	ToAttachedNodeGroupMapOutputWithContext(context.Context) AttachedNodeGroupMapOutput
}

type AttachedNodeGroupMap map[string]AttachedNodeGroupInput

func (AttachedNodeGroupMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AttachedNodeGroup)(nil)).Elem()
}

func (i AttachedNodeGroupMap) ToAttachedNodeGroupMapOutput() AttachedNodeGroupMapOutput {
	return i.ToAttachedNodeGroupMapOutputWithContext(context.Background())
}

func (i AttachedNodeGroupMap) ToAttachedNodeGroupMapOutputWithContext(ctx context.Context) AttachedNodeGroupMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttachedNodeGroupMapOutput)
}

type AttachedNodeGroupOutput struct{ *pulumi.OutputState }

func (AttachedNodeGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AttachedNodeGroup)(nil)).Elem()
}

func (o AttachedNodeGroupOutput) ToAttachedNodeGroupOutput() AttachedNodeGroupOutput {
	return o
}

func (o AttachedNodeGroupOutput) ToAttachedNodeGroupOutputWithContext(ctx context.Context) AttachedNodeGroupOutput {
	return o
}

func (o AttachedNodeGroupOutput) NodeGroup() eks.NodeGroupOutput {
	return o.ApplyT(func(v *AttachedNodeGroup) eks.NodeGroupOutput { return v.NodeGroup }).(eks.NodeGroupOutput)
}

func (o AttachedNodeGroupOutput) NodeRole() iam.RoleOutput {
	return o.ApplyT(func(v *AttachedNodeGroup) iam.RoleOutput { return v.NodeRole }).(iam.RoleOutput)
}

type AttachedNodeGroupArrayOutput struct{ *pulumi.OutputState }

func (AttachedNodeGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AttachedNodeGroup)(nil)).Elem()
}

func (o AttachedNodeGroupArrayOutput) ToAttachedNodeGroupArrayOutput() AttachedNodeGroupArrayOutput {
	return o
}

func (o AttachedNodeGroupArrayOutput) ToAttachedNodeGroupArrayOutputWithContext(ctx context.Context) AttachedNodeGroupArrayOutput {
	return o
}

func (o AttachedNodeGroupArrayOutput) Index(i pulumi.IntInput) AttachedNodeGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AttachedNodeGroup {
		return vs[0].([]*AttachedNodeGroup)[vs[1].(int)]
	}).(AttachedNodeGroupOutput)
}

type AttachedNodeGroupMapOutput struct{ *pulumi.OutputState }

func (AttachedNodeGroupMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AttachedNodeGroup)(nil)).Elem()
}

func (o AttachedNodeGroupMapOutput) ToAttachedNodeGroupMapOutput() AttachedNodeGroupMapOutput {
	return o
}

func (o AttachedNodeGroupMapOutput) ToAttachedNodeGroupMapOutputWithContext(ctx context.Context) AttachedNodeGroupMapOutput {
	return o
}

func (o AttachedNodeGroupMapOutput) MapIndex(k pulumi.StringInput) AttachedNodeGroupOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AttachedNodeGroup {
		return vs[0].(map[string]*AttachedNodeGroup)[vs[1].(string)]
	}).(AttachedNodeGroupOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AttachedNodeGroupInput)(nil)).Elem(), &AttachedNodeGroup{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttachedNodeGroupArrayInput)(nil)).Elem(), AttachedNodeGroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttachedNodeGroupMapInput)(nil)).Elem(), AttachedNodeGroupMap{})
	pulumi.RegisterOutputType(AttachedNodeGroupOutput{})
	pulumi.RegisterOutputType(AttachedNodeGroupArrayOutput{})
	pulumi.RegisterOutputType(AttachedNodeGroupMapOutput{})
}
