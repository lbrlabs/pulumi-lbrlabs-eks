// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package eks

import (
	"context"
	"reflect"

	"errors"
	"github.com/lbrlabs/pulumi-lbrlabs-eks/sdk/go/eks/internal"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/eks"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/iam"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

type AttachedNodeGroup struct {
	pulumi.ResourceState

	NodeGroup eks.NodeGroupOutput `pulumi:"nodeGroup"`
	NodeRole  iam.RoleOutput      `pulumi:"nodeRole"`
}

// NewAttachedNodeGroup registers a new resource with the given unique name, arguments, and options.
func NewAttachedNodeGroup(ctx *pulumi.Context,
	name string, args *AttachedNodeGroupArgs, opts ...pulumi.ResourceOption) (*AttachedNodeGroup, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterName == nil {
		return nil, errors.New("invalid value for required argument 'ClusterName'")
	}
	if args.SubnetIds == nil {
		return nil, errors.New("invalid value for required argument 'SubnetIds'")
	}
	if args.CapacityType == nil {
		args.CapacityType = pulumi.StringPtr("ON_DEMAND")
	}
	if args.DiskSize == nil {
		args.DiskSize = pulumi.Float64Ptr(20.0)
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AttachedNodeGroup
	err := ctx.RegisterRemoteComponentResource("lbrlabs-eks:index:AttachedNodeGroup", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type attachedNodeGroupArgs struct {
	// The capacity type of the nodegroup.
	CapacityType *string `pulumi:"capacityType"`
	// The cluster name to attach the nodegroup tp.
	ClusterName string `pulumi:"clusterName"`
	// The size of the disk to attach to the nodes.
	DiskSize      *float64 `pulumi:"diskSize"`
	InstanceTypes []string `pulumi:"instanceTypes"`
	// Key-value map of Kubernetes labels. Only labels that are applied with the EKS API are managed by this argument. Other Kubernetes labels applied to the EKS Node Group will not be managed.
	Labels        map[string]string           `pulumi:"labels"`
	ScalingConfig *eks.NodeGroupScalingConfig `pulumi:"scalingConfig"`
	SubnetIds     []string                    `pulumi:"subnetIds"`
	// Key-value map of tags to apply to the nodegroup.
	Tags   map[string]string    `pulumi:"tags"`
	Taints []eks.NodeGroupTaint `pulumi:"taints"`
}

// The set of arguments for constructing a AttachedNodeGroup resource.
type AttachedNodeGroupArgs struct {
	// The capacity type of the nodegroup.
	CapacityType pulumi.StringPtrInput
	// The cluster name to attach the nodegroup tp.
	ClusterName pulumi.StringInput
	// The size of the disk to attach to the nodes.
	DiskSize      pulumi.Float64PtrInput
	InstanceTypes pulumi.StringArrayInput
	// Key-value map of Kubernetes labels. Only labels that are applied with the EKS API are managed by this argument. Other Kubernetes labels applied to the EKS Node Group will not be managed.
	Labels        pulumi.StringMapInput
	ScalingConfig eks.NodeGroupScalingConfigPtrInput
	SubnetIds     pulumi.StringArrayInput
	// Key-value map of tags to apply to the nodegroup.
	Tags   pulumi.StringMapInput
	Taints eks.NodeGroupTaintArrayInput
}

func (AttachedNodeGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*attachedNodeGroupArgs)(nil)).Elem()
}

type AttachedNodeGroupInput interface {
	pulumi.Input

	ToAttachedNodeGroupOutput() AttachedNodeGroupOutput
	ToAttachedNodeGroupOutputWithContext(ctx context.Context) AttachedNodeGroupOutput
}

func (*AttachedNodeGroup) ElementType() reflect.Type {
	return reflect.TypeOf((**AttachedNodeGroup)(nil)).Elem()
}

func (i *AttachedNodeGroup) ToAttachedNodeGroupOutput() AttachedNodeGroupOutput {
	return i.ToAttachedNodeGroupOutputWithContext(context.Background())
}

func (i *AttachedNodeGroup) ToAttachedNodeGroupOutputWithContext(ctx context.Context) AttachedNodeGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttachedNodeGroupOutput)
}

func (i *AttachedNodeGroup) ToOutput(ctx context.Context) pulumix.Output[*AttachedNodeGroup] {
	return pulumix.Output[*AttachedNodeGroup]{
		OutputState: i.ToAttachedNodeGroupOutputWithContext(ctx).OutputState,
	}
}

// AttachedNodeGroupArrayInput is an input type that accepts AttachedNodeGroupArray and AttachedNodeGroupArrayOutput values.
// You can construct a concrete instance of `AttachedNodeGroupArrayInput` via:
//
//	AttachedNodeGroupArray{ AttachedNodeGroupArgs{...} }
type AttachedNodeGroupArrayInput interface {
	pulumi.Input

	ToAttachedNodeGroupArrayOutput() AttachedNodeGroupArrayOutput
	ToAttachedNodeGroupArrayOutputWithContext(context.Context) AttachedNodeGroupArrayOutput
}

type AttachedNodeGroupArray []AttachedNodeGroupInput

func (AttachedNodeGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AttachedNodeGroup)(nil)).Elem()
}

func (i AttachedNodeGroupArray) ToAttachedNodeGroupArrayOutput() AttachedNodeGroupArrayOutput {
	return i.ToAttachedNodeGroupArrayOutputWithContext(context.Background())
}

func (i AttachedNodeGroupArray) ToAttachedNodeGroupArrayOutputWithContext(ctx context.Context) AttachedNodeGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttachedNodeGroupArrayOutput)
}

func (i AttachedNodeGroupArray) ToOutput(ctx context.Context) pulumix.Output[[]*AttachedNodeGroup] {
	return pulumix.Output[[]*AttachedNodeGroup]{
		OutputState: i.ToAttachedNodeGroupArrayOutputWithContext(ctx).OutputState,
	}
}

// AttachedNodeGroupMapInput is an input type that accepts AttachedNodeGroupMap and AttachedNodeGroupMapOutput values.
// You can construct a concrete instance of `AttachedNodeGroupMapInput` via:
//
//	AttachedNodeGroupMap{ "key": AttachedNodeGroupArgs{...} }
type AttachedNodeGroupMapInput interface {
	pulumi.Input

	ToAttachedNodeGroupMapOutput() AttachedNodeGroupMapOutput
	ToAttachedNodeGroupMapOutputWithContext(context.Context) AttachedNodeGroupMapOutput
}

type AttachedNodeGroupMap map[string]AttachedNodeGroupInput

func (AttachedNodeGroupMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AttachedNodeGroup)(nil)).Elem()
}

func (i AttachedNodeGroupMap) ToAttachedNodeGroupMapOutput() AttachedNodeGroupMapOutput {
	return i.ToAttachedNodeGroupMapOutputWithContext(context.Background())
}

func (i AttachedNodeGroupMap) ToAttachedNodeGroupMapOutputWithContext(ctx context.Context) AttachedNodeGroupMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttachedNodeGroupMapOutput)
}

func (i AttachedNodeGroupMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*AttachedNodeGroup] {
	return pulumix.Output[map[string]*AttachedNodeGroup]{
		OutputState: i.ToAttachedNodeGroupMapOutputWithContext(ctx).OutputState,
	}
}

type AttachedNodeGroupOutput struct{ *pulumi.OutputState }

func (AttachedNodeGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AttachedNodeGroup)(nil)).Elem()
}

func (o AttachedNodeGroupOutput) ToAttachedNodeGroupOutput() AttachedNodeGroupOutput {
	return o
}

func (o AttachedNodeGroupOutput) ToAttachedNodeGroupOutputWithContext(ctx context.Context) AttachedNodeGroupOutput {
	return o
}

func (o AttachedNodeGroupOutput) ToOutput(ctx context.Context) pulumix.Output[*AttachedNodeGroup] {
	return pulumix.Output[*AttachedNodeGroup]{
		OutputState: o.OutputState,
	}
}

func (o AttachedNodeGroupOutput) NodeGroup() eks.NodeGroupOutput {
	return o.ApplyT(func(v *AttachedNodeGroup) eks.NodeGroupOutput { return v.NodeGroup }).(eks.NodeGroupOutput)
}

func (o AttachedNodeGroupOutput) NodeRole() iam.RoleOutput {
	return o.ApplyT(func(v *AttachedNodeGroup) iam.RoleOutput { return v.NodeRole }).(iam.RoleOutput)
}

type AttachedNodeGroupArrayOutput struct{ *pulumi.OutputState }

func (AttachedNodeGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AttachedNodeGroup)(nil)).Elem()
}

func (o AttachedNodeGroupArrayOutput) ToAttachedNodeGroupArrayOutput() AttachedNodeGroupArrayOutput {
	return o
}

func (o AttachedNodeGroupArrayOutput) ToAttachedNodeGroupArrayOutputWithContext(ctx context.Context) AttachedNodeGroupArrayOutput {
	return o
}

func (o AttachedNodeGroupArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*AttachedNodeGroup] {
	return pulumix.Output[[]*AttachedNodeGroup]{
		OutputState: o.OutputState,
	}
}

func (o AttachedNodeGroupArrayOutput) Index(i pulumi.IntInput) AttachedNodeGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AttachedNodeGroup {
		return vs[0].([]*AttachedNodeGroup)[vs[1].(int)]
	}).(AttachedNodeGroupOutput)
}

type AttachedNodeGroupMapOutput struct{ *pulumi.OutputState }

func (AttachedNodeGroupMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AttachedNodeGroup)(nil)).Elem()
}

func (o AttachedNodeGroupMapOutput) ToAttachedNodeGroupMapOutput() AttachedNodeGroupMapOutput {
	return o
}

func (o AttachedNodeGroupMapOutput) ToAttachedNodeGroupMapOutputWithContext(ctx context.Context) AttachedNodeGroupMapOutput {
	return o
}

func (o AttachedNodeGroupMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*AttachedNodeGroup] {
	return pulumix.Output[map[string]*AttachedNodeGroup]{
		OutputState: o.OutputState,
	}
}

func (o AttachedNodeGroupMapOutput) MapIndex(k pulumi.StringInput) AttachedNodeGroupOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AttachedNodeGroup {
		return vs[0].(map[string]*AttachedNodeGroup)[vs[1].(string)]
	}).(AttachedNodeGroupOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AttachedNodeGroupInput)(nil)).Elem(), &AttachedNodeGroup{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttachedNodeGroupArrayInput)(nil)).Elem(), AttachedNodeGroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttachedNodeGroupMapInput)(nil)).Elem(), AttachedNodeGroupMap{})
	pulumi.RegisterOutputType(AttachedNodeGroupOutput{})
	pulumi.RegisterOutputType(AttachedNodeGroupArrayOutput{})
	pulumi.RegisterOutputType(AttachedNodeGroupMapOutput{})
}
