// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package eks

import (
	"context"
	"reflect"

	"errors"
	"github.com/lbrlabs/pulumi-lbrlabs-eks/sdk/go/eks/internal"
	corev1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/core/v1"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type AutoscaledNodeGroup struct {
	pulumi.ResourceState
}

// NewAutoscaledNodeGroup registers a new resource with the given unique name, arguments, and options.
func NewAutoscaledNodeGroup(ctx *pulumi.Context,
	name string, args *AutoscaledNodeGroupArgs, opts ...pulumi.ResourceOption) (*AutoscaledNodeGroup, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.NodeRole == nil {
		return nil, errors.New("invalid value for required argument 'NodeRole'")
	}
	if args.Requirements == nil {
		return nil, errors.New("invalid value for required argument 'Requirements'")
	}
	if args.SecurityGroupIds == nil {
		return nil, errors.New("invalid value for required argument 'SecurityGroupIds'")
	}
	if args.SubnetIds == nil {
		return nil, errors.New("invalid value for required argument 'SubnetIds'")
	}
	if args.ApiVersion == nil {
		args.ApiVersion = pulumi.StringPtr("v1")
	}
	if args.DiskSize == nil {
		args.DiskSize = pulumi.String("20Gi")
	}
	if args.Disruption != nil {
		args.Disruption = args.Disruption.ToDisruptionConfigPtrOutput().ApplyT(func(v *DisruptionConfig) *DisruptionConfig { return v.Defaults() }).(DisruptionConfigPtrOutput)
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AutoscaledNodeGroup
	err := ctx.RegisterRemoteComponentResource("lbrlabs-eks:index:AutoscaledNodeGroup", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type autoscaledNodeGroupArgs struct {
	// AMI family for the node group.
	AmiFamily *string `pulumi:"amiFamily"`
	// AMI ID for the node group.
	AmiId *string `pulumi:"amiId"`
	// Annotations to apply to the node group.
	Annotations map[string]string `pulumi:"annotations"`
	// Karpenter API version.
	ApiVersion *string `pulumi:"apiVersion"`
	// Disk size for the node group.
	DiskSize   string            `pulumi:"diskSize"`
	Disruption *DisruptionConfig `pulumi:"disruption"`
	// Key-value map of Kubernetes labels. Only labels that are applied with the EKS API are managed by this argument. Other Kubernetes labels applied to the EKS Node Group will not be managed.
	Labels map[string]string `pulumi:"labels"`
	// Node role for the node group.
	NodeRole string `pulumi:"nodeRole"`
	// List of requirements for the node group.
	Requirements []Requirement `pulumi:"requirements"`
	// List of security group selector terms for the node group.
	SecurityGroupIds []string `pulumi:"securityGroupIds"`
	// List of subnet selector terms for the node group.
	SubnetIds []string `pulumi:"subnetIds"`
	// Optional node taints.
	Taints []corev1.Taint `pulumi:"taints"`
}

// The set of arguments for constructing a AutoscaledNodeGroup resource.
type AutoscaledNodeGroupArgs struct {
	// AMI family for the node group.
	AmiFamily pulumi.StringPtrInput
	// AMI ID for the node group.
	AmiId pulumi.StringPtrInput
	// Annotations to apply to the node group.
	Annotations pulumi.StringMapInput
	// Karpenter API version.
	ApiVersion pulumi.StringPtrInput
	// Disk size for the node group.
	DiskSize   pulumi.StringInput
	Disruption DisruptionConfigPtrInput
	// Key-value map of Kubernetes labels. Only labels that are applied with the EKS API are managed by this argument. Other Kubernetes labels applied to the EKS Node Group will not be managed.
	Labels pulumi.StringMapInput
	// Node role for the node group.
	NodeRole pulumi.StringInput
	// List of requirements for the node group.
	Requirements RequirementArrayInput
	// List of security group selector terms for the node group.
	SecurityGroupIds pulumi.StringArrayInput
	// List of subnet selector terms for the node group.
	SubnetIds pulumi.StringArrayInput
	// Optional node taints.
	Taints corev1.TaintArrayInput
}

func (AutoscaledNodeGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*autoscaledNodeGroupArgs)(nil)).Elem()
}

type AutoscaledNodeGroupInput interface {
	pulumi.Input

	ToAutoscaledNodeGroupOutput() AutoscaledNodeGroupOutput
	ToAutoscaledNodeGroupOutputWithContext(ctx context.Context) AutoscaledNodeGroupOutput
}

func (*AutoscaledNodeGroup) ElementType() reflect.Type {
	return reflect.TypeOf((**AutoscaledNodeGroup)(nil)).Elem()
}

func (i *AutoscaledNodeGroup) ToAutoscaledNodeGroupOutput() AutoscaledNodeGroupOutput {
	return i.ToAutoscaledNodeGroupOutputWithContext(context.Background())
}

func (i *AutoscaledNodeGroup) ToAutoscaledNodeGroupOutputWithContext(ctx context.Context) AutoscaledNodeGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoscaledNodeGroupOutput)
}

// AutoscaledNodeGroupArrayInput is an input type that accepts AutoscaledNodeGroupArray and AutoscaledNodeGroupArrayOutput values.
// You can construct a concrete instance of `AutoscaledNodeGroupArrayInput` via:
//
//	AutoscaledNodeGroupArray{ AutoscaledNodeGroupArgs{...} }
type AutoscaledNodeGroupArrayInput interface {
	pulumi.Input

	ToAutoscaledNodeGroupArrayOutput() AutoscaledNodeGroupArrayOutput
	ToAutoscaledNodeGroupArrayOutputWithContext(context.Context) AutoscaledNodeGroupArrayOutput
}

type AutoscaledNodeGroupArray []AutoscaledNodeGroupInput

func (AutoscaledNodeGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AutoscaledNodeGroup)(nil)).Elem()
}

func (i AutoscaledNodeGroupArray) ToAutoscaledNodeGroupArrayOutput() AutoscaledNodeGroupArrayOutput {
	return i.ToAutoscaledNodeGroupArrayOutputWithContext(context.Background())
}

func (i AutoscaledNodeGroupArray) ToAutoscaledNodeGroupArrayOutputWithContext(ctx context.Context) AutoscaledNodeGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoscaledNodeGroupArrayOutput)
}

// AutoscaledNodeGroupMapInput is an input type that accepts AutoscaledNodeGroupMap and AutoscaledNodeGroupMapOutput values.
// You can construct a concrete instance of `AutoscaledNodeGroupMapInput` via:
//
//	AutoscaledNodeGroupMap{ "key": AutoscaledNodeGroupArgs{...} }
type AutoscaledNodeGroupMapInput interface {
	pulumi.Input

	ToAutoscaledNodeGroupMapOutput() AutoscaledNodeGroupMapOutput
	ToAutoscaledNodeGroupMapOutputWithContext(context.Context) AutoscaledNodeGroupMapOutput
}

type AutoscaledNodeGroupMap map[string]AutoscaledNodeGroupInput

func (AutoscaledNodeGroupMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AutoscaledNodeGroup)(nil)).Elem()
}

func (i AutoscaledNodeGroupMap) ToAutoscaledNodeGroupMapOutput() AutoscaledNodeGroupMapOutput {
	return i.ToAutoscaledNodeGroupMapOutputWithContext(context.Background())
}

func (i AutoscaledNodeGroupMap) ToAutoscaledNodeGroupMapOutputWithContext(ctx context.Context) AutoscaledNodeGroupMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoscaledNodeGroupMapOutput)
}

type AutoscaledNodeGroupOutput struct{ *pulumi.OutputState }

func (AutoscaledNodeGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AutoscaledNodeGroup)(nil)).Elem()
}

func (o AutoscaledNodeGroupOutput) ToAutoscaledNodeGroupOutput() AutoscaledNodeGroupOutput {
	return o
}

func (o AutoscaledNodeGroupOutput) ToAutoscaledNodeGroupOutputWithContext(ctx context.Context) AutoscaledNodeGroupOutput {
	return o
}

type AutoscaledNodeGroupArrayOutput struct{ *pulumi.OutputState }

func (AutoscaledNodeGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AutoscaledNodeGroup)(nil)).Elem()
}

func (o AutoscaledNodeGroupArrayOutput) ToAutoscaledNodeGroupArrayOutput() AutoscaledNodeGroupArrayOutput {
	return o
}

func (o AutoscaledNodeGroupArrayOutput) ToAutoscaledNodeGroupArrayOutputWithContext(ctx context.Context) AutoscaledNodeGroupArrayOutput {
	return o
}

func (o AutoscaledNodeGroupArrayOutput) Index(i pulumi.IntInput) AutoscaledNodeGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AutoscaledNodeGroup {
		return vs[0].([]*AutoscaledNodeGroup)[vs[1].(int)]
	}).(AutoscaledNodeGroupOutput)
}

type AutoscaledNodeGroupMapOutput struct{ *pulumi.OutputState }

func (AutoscaledNodeGroupMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AutoscaledNodeGroup)(nil)).Elem()
}

func (o AutoscaledNodeGroupMapOutput) ToAutoscaledNodeGroupMapOutput() AutoscaledNodeGroupMapOutput {
	return o
}

func (o AutoscaledNodeGroupMapOutput) ToAutoscaledNodeGroupMapOutputWithContext(ctx context.Context) AutoscaledNodeGroupMapOutput {
	return o
}

func (o AutoscaledNodeGroupMapOutput) MapIndex(k pulumi.StringInput) AutoscaledNodeGroupOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AutoscaledNodeGroup {
		return vs[0].(map[string]*AutoscaledNodeGroup)[vs[1].(string)]
	}).(AutoscaledNodeGroupOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AutoscaledNodeGroupInput)(nil)).Elem(), &AutoscaledNodeGroup{})
	pulumi.RegisterInputType(reflect.TypeOf((*AutoscaledNodeGroupArrayInput)(nil)).Elem(), AutoscaledNodeGroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AutoscaledNodeGroupMapInput)(nil)).Elem(), AutoscaledNodeGroupMap{})
	pulumi.RegisterOutputType(AutoscaledNodeGroupOutput{})
	pulumi.RegisterOutputType(AutoscaledNodeGroupArrayOutput{})
	pulumi.RegisterOutputType(AutoscaledNodeGroupMapOutput{})
}
