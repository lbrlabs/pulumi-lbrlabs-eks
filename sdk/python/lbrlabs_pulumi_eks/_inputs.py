# coding=utf-8
# *** WARNING: this file was generated by Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'BudgetConfigArgs',
    'BudgetConfigArgsDict',
    'DisruptionConfigArgs',
    'DisruptionConfigArgsDict',
    'IngressConfigArgs',
    'IngressConfigArgsDict',
    'RequirementArgs',
    'RequirementArgsDict',
]

MYPY = False

if not MYPY:
    class BudgetConfigArgsDict(TypedDict):
        """
        Configuration for Autoscaled Node budgets.
        """
        duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        The duration during which disruptuon can happen.
        """
        nodes: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum number of nodes that can be scaled down at any time.
        """
        schedule: NotRequired[pulumi.Input[_builtins.str]]
        """
        A cron schedule for when disruption can happen.
        """
elif False:
    BudgetConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetConfigArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.str]] = None,
                 nodes: Optional[pulumi.Input[_builtins.str]] = None,
                 schedule: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Configuration for Autoscaled Node budgets.
        :param pulumi.Input[_builtins.str] duration: The duration during which disruptuon can happen.
        :param pulumi.Input[_builtins.str] nodes: The maximum number of nodes that can be scaled down at any time.
        :param pulumi.Input[_builtins.str] schedule: A cron schedule for when disruption can happen.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The duration during which disruptuon can happen.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum number of nodes that can be scaled down at any time.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nodes", value)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A cron schedule for when disruption can happen.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class DisruptionConfigArgsDict(TypedDict):
        """
        Configuration for Autoscaled nodes disruption.
        """
        budgets: NotRequired[pulumi.Input[Sequence[pulumi.Input['BudgetConfigArgsDict']]]]
        """
        Budgets control the speed Karpenter can scale down nodes.
        """
        consolidate_after: NotRequired[pulumi.Input[_builtins.str]]
        """
        The amount of time Karpenter should wait after discovering a consolidation decision. This value can currently only be set when the consolidationPolicy is 'WhenEmpty'. You can choose to disable consolidation entirely by setting the string value 'Never' here.
        """
        consolidation_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Describes which types of Nodes Karpenter should consider for consolidation.
        """
        expire_after: NotRequired[pulumi.Input[_builtins.str]]
        """
        The amount of time a Node can live on the cluster before being removed.
        """
elif False:
    DisruptionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DisruptionConfigArgs:
    def __init__(__self__, *,
                 budgets: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetConfigArgs']]]] = None,
                 consolidate_after: Optional[pulumi.Input[_builtins.str]] = None,
                 consolidation_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 expire_after: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Configuration for Autoscaled nodes disruption.
        :param pulumi.Input[Sequence[pulumi.Input['BudgetConfigArgs']]] budgets: Budgets control the speed Karpenter can scale down nodes.
        :param pulumi.Input[_builtins.str] consolidate_after: The amount of time Karpenter should wait after discovering a consolidation decision. This value can currently only be set when the consolidationPolicy is 'WhenEmpty'. You can choose to disable consolidation entirely by setting the string value 'Never' here.
        :param pulumi.Input[_builtins.str] consolidation_policy: Describes which types of Nodes Karpenter should consider for consolidation.
        :param pulumi.Input[_builtins.str] expire_after: The amount of time a Node can live on the cluster before being removed.
        """
        if budgets is not None:
            pulumi.set(__self__, "budgets", budgets)
        if consolidate_after is None:
            consolidate_after = '10m'
        if consolidate_after is not None:
            pulumi.set(__self__, "consolidate_after", consolidate_after)
        if consolidation_policy is None:
            consolidation_policy = 'WhenEmpty'
        if consolidation_policy is not None:
            pulumi.set(__self__, "consolidation_policy", consolidation_policy)
        if expire_after is not None:
            pulumi.set(__self__, "expire_after", expire_after)

    @_builtins.property
    @pulumi.getter
    def budgets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BudgetConfigArgs']]]]:
        """
        Budgets control the speed Karpenter can scale down nodes.
        """
        return pulumi.get(self, "budgets")

    @budgets.setter
    def budgets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetConfigArgs']]]]):
        pulumi.set(self, "budgets", value)

    @_builtins.property
    @pulumi.getter(name="consolidateAfter")
    def consolidate_after(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The amount of time Karpenter should wait after discovering a consolidation decision. This value can currently only be set when the consolidationPolicy is 'WhenEmpty'. You can choose to disable consolidation entirely by setting the string value 'Never' here.
        """
        return pulumi.get(self, "consolidate_after")

    @consolidate_after.setter
    def consolidate_after(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consolidate_after", value)

    @_builtins.property
    @pulumi.getter(name="consolidationPolicy")
    def consolidation_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Describes which types of Nodes Karpenter should consider for consolidation.
        """
        return pulumi.get(self, "consolidation_policy")

    @consolidation_policy.setter
    def consolidation_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consolidation_policy", value)

    @_builtins.property
    @pulumi.getter(name="expireAfter")
    def expire_after(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The amount of time a Node can live on the cluster before being removed.
        """
        return pulumi.get(self, "expire_after")

    @expire_after.setter
    def expire_after(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expire_after", value)


if not MYPY:
    class IngressConfigArgsDict(TypedDict):
        """
        Configuration for the ingress controller.
        """
        additional_config: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional configuration for the ingress controller.
        """
        allow_snippet_annotations: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to allow snippet annotations in the ingress controller.
        """
        controller_replicas: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of replicas of the ingress controller.
        """
        enable_metrics: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable metrics for the ingress controller.
        """
        enable_service_monitor: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable the service monitor for kube-prometheus-stackl.
        """
        nlb_target_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        NLB target type for NLB loadbalancers.
        """
        service_monitor_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to deploy the service monitor to.
        """
elif False:
    IngressConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IngressConfigArgs:
    def __init__(__self__, *,
                 additional_config: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 allow_snippet_annotations: Optional[pulumi.Input[_builtins.bool]] = None,
                 controller_replicas: Optional[pulumi.Input[_builtins.int]] = None,
                 enable_metrics: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_service_monitor: Optional[pulumi.Input[_builtins.bool]] = None,
                 nlb_target_type: Optional[pulumi.Input[_builtins.str]] = None,
                 service_monitor_namespace: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Configuration for the ingress controller.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] additional_config: Additional configuration for the ingress controller.
        :param pulumi.Input[_builtins.bool] allow_snippet_annotations: Whether to allow snippet annotations in the ingress controller.
        :param pulumi.Input[_builtins.int] controller_replicas: The number of replicas of the ingress controller.
        :param pulumi.Input[_builtins.bool] enable_metrics: Enable metrics for the ingress controller.
        :param pulumi.Input[_builtins.bool] enable_service_monitor: Enable the service monitor for kube-prometheus-stackl.
        :param pulumi.Input[_builtins.str] nlb_target_type: NLB target type for NLB loadbalancers.
        :param pulumi.Input[_builtins.str] service_monitor_namespace: The namespace to deploy the service monitor to.
        """
        if additional_config is not None:
            pulumi.set(__self__, "additional_config", additional_config)
        if allow_snippet_annotations is None:
            allow_snippet_annotations = False
        if allow_snippet_annotations is not None:
            pulumi.set(__self__, "allow_snippet_annotations", allow_snippet_annotations)
        if controller_replicas is None:
            controller_replicas = 1
        if controller_replicas is not None:
            pulumi.set(__self__, "controller_replicas", controller_replicas)
        if enable_metrics is None:
            enable_metrics = False
        if enable_metrics is not None:
            pulumi.set(__self__, "enable_metrics", enable_metrics)
        if enable_service_monitor is None:
            enable_service_monitor = False
        if enable_service_monitor is not None:
            pulumi.set(__self__, "enable_service_monitor", enable_service_monitor)
        if nlb_target_type is None:
            nlb_target_type = 'ip'
        if nlb_target_type is not None:
            pulumi.set(__self__, "nlb_target_type", nlb_target_type)
        if service_monitor_namespace is not None:
            pulumi.set(__self__, "service_monitor_namespace", service_monitor_namespace)

    @_builtins.property
    @pulumi.getter(name="additionalConfig")
    def additional_config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional configuration for the ingress controller.
        """
        return pulumi.get(self, "additional_config")

    @additional_config.setter
    def additional_config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "additional_config", value)

    @_builtins.property
    @pulumi.getter(name="allowSnippetAnnotations")
    def allow_snippet_annotations(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to allow snippet annotations in the ingress controller.
        """
        return pulumi.get(self, "allow_snippet_annotations")

    @allow_snippet_annotations.setter
    def allow_snippet_annotations(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_snippet_annotations", value)

    @_builtins.property
    @pulumi.getter(name="controllerReplicas")
    def controller_replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of replicas of the ingress controller.
        """
        return pulumi.get(self, "controller_replicas")

    @controller_replicas.setter
    def controller_replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "controller_replicas", value)

    @_builtins.property
    @pulumi.getter(name="enableMetrics")
    def enable_metrics(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable metrics for the ingress controller.
        """
        return pulumi.get(self, "enable_metrics")

    @enable_metrics.setter
    def enable_metrics(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_metrics", value)

    @_builtins.property
    @pulumi.getter(name="enableServiceMonitor")
    def enable_service_monitor(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable the service monitor for kube-prometheus-stackl.
        """
        return pulumi.get(self, "enable_service_monitor")

    @enable_service_monitor.setter
    def enable_service_monitor(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_service_monitor", value)

    @_builtins.property
    @pulumi.getter(name="nlbTargetType")
    def nlb_target_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        NLB target type for NLB loadbalancers.
        """
        return pulumi.get(self, "nlb_target_type")

    @nlb_target_type.setter
    def nlb_target_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nlb_target_type", value)

    @_builtins.property
    @pulumi.getter(name="serviceMonitorNamespace")
    def service_monitor_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to deploy the service monitor to.
        """
        return pulumi.get(self, "service_monitor_namespace")

    @service_monitor_namespace.setter
    def service_monitor_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_monitor_namespace", value)


if not MYPY:
    class RequirementArgsDict(TypedDict):
        """
        Represents a single requirement with key, operator, and values.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the requirement.
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        The operator for the requirement (e.g., In, Gt).
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of values for the requirement.
        """
elif False:
    RequirementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RequirementArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Represents a single requirement with key, operator, and values.
        :param pulumi.Input[_builtins.str] key: The key of the requirement.
        :param pulumi.Input[_builtins.str] operator: The operator for the requirement (e.g., In, Gt).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: The list of values for the requirement.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the requirement.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The operator for the requirement (e.g., In, Gt).
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of values for the requirement.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


